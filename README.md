# Домашнє завдання goit-algo-hw-04

## Порівняння алгоритмів сортування: Insertion Sort, Merge Sort і Timsort

### Мета
Метою цього завдання є емпіричне підтвердження теоретичної складності трьох алгоритмів сортування:
- Сортування вставками (Insertion Sort)
- Сортування злиттям (Merge Sort)
- Вбудованого алгоритму Python `sorted()` (Timsort)

---

### Теоретична складність

| Алгоритм         | Найгірший випадок | Середній випадок | Найкращий випадок |
|------------------|-------------------|-------------------|--------------------|
| Insertion Sort   | O(n²)             | O(n²)             | O(n)               |
| Merge Sort       | O(n log n)        | O(n log n)        | O(n log n)         |
| Timsort (Python) | O(n log n)        | O(n log n)        | O(n)               |

---

### Емпіричні тести

Було проведено тестування алгоритмів на масивах розміром 100, 1000 та 5000 елементів. Для вимірювання часу використано модуль `timeit`.

#### Результат вимірювання часу (секунди):

| Розмір масиву | Insertion Sort | Merge Sort | Timsort |
|---------------|----------------|------------|---------|
| 100           | 0.0000099        | 0.000110   | 0.000007 |
| 1000          | 0.000989        | 0.014053    | 0.000072 |
| 5000          | 0.006574        | 0.303921    | 0.000471 |

---

### Висновки

- **Insertion Sort** є повільним на великих наборах даних через квадратичну складність, хоч і підходить для малих масивів.
- **Merge Sort** демонструє стабільну ефективність, проте поступається Timsort на практиці.
- **Timsort**, який поєднує сортування злиттям і вставками, є найшвидшим в усіх тестах.

Саме тому Python використовує Timsort у функціях `sorted()` та `.sort()` — цей алгоритм здатен ефективно обробляти як великі, так і частково відсортовані масиви.

---

### Файли у репозиторії

- `main.py` — код порівняння алгоритмів
- `README.md` — пояснення та висновки
